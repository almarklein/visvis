This document provides information on how to implement a backend in
Visvis, and explains how the backend GUI interacts with Visvis.


** Introduction **

To create a backend, one needs an OpenGl widget, and inherit from it
to implement the interaction with visvis. This widget (let's call it
GlCanvas) is what will be used in a Gui application that embeds visvis.
For interactive use, the widget has no parent and is the main window,
or is wrapped in a main window widget if necessary (as in wx).

Furthermore, an implementation of the BaseFigure class should be
provided, called Figure. A few (private) methods should be implemented to give
Visvis a way to interact with the underlying toolkit.

The GlCanvas and Figure instances that together make up a working
base for drawing in visvis, each have a reference of each other:
".figure"  and "._widget".

Below you'll find the details of implementing a backend. Also see
the already existing backend implementations for an example.


** Interaction between GUI and Visvis **

Draw commands can come from two sources: from the GUI because the 
widget was resized or previously occluded, and from within Visvis,
because something was changed (for example while zooming).
The following pseudocode explains how these both result in visvis
drawing the scene.

{{{
Figure.Draw(self):
  # Entry point for draw requests from within Visvis.
  # Consequetive draw requests result in a single draw.
  if not self._drawTimer.IsRunning():
    self._drawTimer.Start()

Figure._DrawTimerTimeOutHandler(self):
  self._RedrawGui()

Figure._RedrawGui():
  # This method needs to be implemented to call the right
  # update function, as the name differs per toolkit.
  self._widget.MethodToRequestRedraw()

GlCanvas.MethodToRequestRedraw(self): 
  # Entry point for draw requests from the GUI.
  # This method is always implemented by the GUI toolkit.
  # Will post an event to fire GlCanvas.MethodToReallyDraw() 
  ...

GlCanvas.MethodToReallyDraw(self):
  # Draw Now. Sometimes this method needs to be overloaded, sometimes
  # one has to bind to a draw event.  
  self.figure.OnDraw()

Figure.OnDraw(self):
  # This method will perform all OpenGl commands.
  ...
}}}


Simularly, closing the figure may also be done via two ways: by 
clicking on the cross of the widget's title bar, or by calling
Figure.Destroy(). In the following pseudocode the mechanisms 
behind closing and cleaning up are explained:

{{{
Figure.Destroy(self):
  # Calls OnDestroy() of all children of the figure to clean up, 
  # and then calls OnDestroy() on itself.
  ...
  self.OnDestroy()

Figure.OnDestroy(self):
  if self._widget:
    self.eventClose.Fire()
    # Detach
    self._widget.figure = None
    self._widget = None
    # Make the window disappear
    self._Close()
    # Remove figure from list of figures
    ...

Figure._Close(self):
  # This method needs to be implemented to call the right
  # update function, as the name differs per toolkit.
  # In FLTK, GlCanvas.MethodToReallyClose() is called directly.
	self._widget.MethodToRequestClose()

GlCanvas.MethodToRequestClose(self):  
  # Entry point for close requests from the GUI.
  # This method is always implemented by the GUI toolkit.
  # Will post an event to fire GlCanvas.MethodToReallyClose() 
  ...
  
GlCanvas.MethodToReallyClose(self):
  # Close Now. Sometimes this method needs to be overloaded, sometimes
  # one has to bind to a close event.
  if self.figure:
    self.figure.Destroy()
  self.hide()
}}}


** Interaction of the event systems **

Basically, visvis needs the GUI backend to function properly.
The backend should make sure to periodically call 
events.processVisvisEvents(). This can be done using a timer.

Nonetheless, this means that the events of the underlying widget 
toolkit need to be periodically processed too. When the GUI mainloop
is running (for example when visvis is embedded in an application)
this works fine, but for interactive use, this mainloop has to be 
simulated.

IPython solves this by starting a GUI eventloop in a seperate thread.
That means using visvis with the wx backend requires using the -wthread
option. For the qt4 backend, the -q4thread option can be used, although
it does not seem necessary, because IPython updates the tk evens, and
somehow qt is able to hook into that (I'm not sure how this works
exactly). IPython does AFAIK not support processing FLTK events.

In IEP, the events can be processed for all three backend. In contrast
to IPython, the events are processed when waiting for user input, this
means the GUI's (and visvis) become unresponsive if the process is
running some algorithm.

Each backend should implement an App class that wraps the GUI toolkit's
application instance (if any). It should make sure that there is only
one such instance (for example QtGui.QApplication.instance()), even
if multiple instances of the visvis App class are made. The class 
should implement a Run() method to enter the mainloop, and a 
ProcessEvents() method to process the GUI events.

Using the visvis function vv.use(), an instance of such a class can
be obtained (optionally giving a backend name). The same instance
is stored and used by vv.processEvents() function. The Figure class
implemented by the backend also implements a _ProcessGuiEvents() 
method, which does the same thing.

An instance of the App class should wait with creating an application
instance of the GUI toolkit as late as possible. By making sure it
exists inside the newFigure() function, all should be well. This is to
enable using "vv.use()" in an embedded application where at the end
the code will explicitly create an application object of the GUI.


** Implementing GlCanvas **
