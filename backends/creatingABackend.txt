This document provides information on how to implement a backend in
Visvis, and explains how the backend GUI interacts with Visvis.


** Introduction **

To create a backend, one needs an OpenGl widget, and inherit from it
to implement the interaction with visvis. This widget (let's call it
GlCanvas) is what will be used in a Gui application that embeds visvis.
For interactive use, the widget has no parent and is the main window,
or is wrapped in a main window widget if necessary (as in wx).

Furthermore, an implementation of the BaseFigure class should be
provided, called Figure. A few (private) methods should be implemented to give
Visvis a way to interact with the underlying toolkit.

The GlCanvas and Figure instances that together make up a working
base for drawing in visvis, each have a reference of each other:
".figure"  and "._widget".

Below you'll find the details of implementing a backend. Also see
the already existing backend implementations for an example.


** Interaction between GUI and Visvis **

Draw commands can come from two sources: from the GUI because the 
widget was resized or previously occluded, and from within Visvis,
because something was changed (for example while zooming).
The following pseudocode explains how these both result in visvis
drawing the scene.

{{{
Figure.Draw(self):
  # Entry point for draw requests from within Visvis.
  # Consequetive draw requests result in a single draw.
  if not self._drawTimer.IsRunning():
    self._drawTimer.Start()

Figure._DrawTimerTimeOutHandler(self):
  self._RedrawGui()

Figure._RedrawGui():
  # This method needs to be implemented to call the right
  # update function, as the name differs per toolkit.
  self._widget.MethodToRequestRedraw()

GlCanvas.MethodToRequestRedraw(self): 
  # Entry point for draw requests from the GUI.
  # This method is always implemented by the GUI toolkit.
  # Will post an event to fire GlCanvas.MethodToReallyDraw() 
  ...

GlCanvas.MethodToReallyDraw(self):
  # Draw Now. Sometimes this method needs to be overloaded, sometimes
  # one has to bind to a draw event.  
  self.figure.OnDraw()

Figure.OnDraw(self):
  # This method will perform all OpenGl commands.
  ...
}}}


Simularly, closing the figure may also be done via two ways: by 
clicking on the cross of the widget's title bar, or by calling
Figure.Destroy(). In the following pseudocode the mechanisms 
behind closing and cleaning up are explained:

{{{
Figure.Destroy(self):
  # Calls OnDestroy() of all children of the figure to clean up, 
  # and then calls OnDestroy() on itself.
  ...
  self.OnDestroy()

Figure.OnDestroy(self):
  if self._widget:
    self.eventClose.Fire()
    # Detach
    self._widget.figure = None
    self._widget = None
    # Make the window disappear
    self._Close()
    # Remove figure from list of figures
    ...

Figure._Close(self):
  # This method needs to be implemented to call the right
  # update function, as the name differs per toolkit.
  # In FLTK, GlCanvas.MethodToReallyClose() is called directly.
	self._widget.MethodToRequestClose()

GlCanvas.MethodToRequestClose(self):  
  # Entry point for close requests from the GUI.
  # This method is always implemented by the GUI toolkit.
  # Will post an event to fire GlCanvas.MethodToReallyClose() 
  ...
  
GlCanvas.MethodToReallyClose(self):
  # Close Now. Sometimes this method needs to be overloaded, sometimes
  # one has to bind to a close event.
  if self.figure:
    self.figure.Destroy()
  self.hide()
}}}


An finally, here is the pseudocode that explains the mechanisms
for keeping the event systems of both Vivis and the GUI toolkit
running.
{{{

}}}


** Implementing GlCanvas **
